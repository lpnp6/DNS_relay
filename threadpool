#include "Header.h"
#pragma warning(disable:4996)
extern thread threadpool[threadNum];
extern bool isBusy[threadNum];
extern map<string, string>ip_domain_Map;//DNS域名解析表
extern char LocalDNSAddress[IPLength];
extern char DefDNSAddress[IPLength];
extern char filePath[MAX_FILE_LENGTH];
extern int DebugLevel;
extern map<char*, cacheInfo>cache;//cache表
extern ID_trans id_trans_table[AMOUNT];	//ID转换表
extern int IDcount;			//转换表中的条目个数
extern char Url[lengthURL];					//域名
extern SYSTEMTIME TimeOfSys;                     //系统时间

void newthread(int i,SOCKET servSock, SOCKET localSock,SOCKADDR_IN serverName, SOCKADDR_IN clientName, char*recvBuf,int iRecv, int client_len)
{
	const char* getIP;
	unsigned short NewID;
	unsigned short* pID;
	int iSend;
	int clen = client_len;
	char recvBuff[BUFSIZE];
	char sendBuf[BUFSIZE]; //发送缓存
	memcpy(recvBuff,recvBuf,sizeof(char)*BUFSIZE);

	DNS_Packet packet;
	parseDNSPacket(&packet, recvBuff);

	GetUrl(recvBuff, iRecv);
	getIP = handlecache(Url);	//在域名解析表中查找

	pID = (unsigned short*)malloc(sizeof(unsigned short*));
	memcpy(pID, recvBuff, sizeof(unsigned short)); //报文前两字节为ID
	if (DebugLevel >= 1)
		PrintRecvInfo(clientName, &packet, ntohs(*pID), Url, iRecv);
	//printf("We have get the url: %s\n", Url);

	//printf("%d\n", find);

	//开始分情况讨论
	//在域名解析表中没有找到
	if (getIP == NULL)
	{

		//printf("We dont find this url, will get a new ID and forward to SERVER.\n");
		//ID转换
		//pID = new (unsigned short);

		NewID = htons(replace_id(ntohs(*pID), clientName, FALSE));
		memcpy(recvBuff, &NewID, sizeof(unsigned short));
		
		//把recvbuf转发至指定的外部DNS服务器
		iSend = sendto(servSock, recvBuff, iRecv, 0, (SOCKADDR*)&serverName, sizeof(serverName));
		if (iSend == SOCKET_ERROR)
		{
			//printf("sendto Failed: %s\n", strerror(WSAGetLastError()));
			isBusy[i] = false;
			return ;
		}
		else if (iSend == 0)
		{
			isBusy[i] = false;
			return;
		}
		else if (iSend > 0 && DebugLevel >= 1)
			PrintSendInfo(serverName, &packet, *pID, NewID, getIP);

		//delete pID; //释放动态分配的内存
		free(pID);
		clock_t start, stop; //定时
		double duration = 0;
		//接收来自外部DNS服务器的响应报文
		start = clock();

		bool flag = 1;
		iRecv = recvfrom(servSock, recvBuff, sizeof(recvBuff), 0, (SOCKADDR*)&clientName, &clen);
		if (iRecv > 0 && DebugLevel >= 1)
			PrintRecvInfo(clientName, &packet, ntohs(*(u_short*)recvBuff), Url, iRecv);
		while ((iRecv == 0) || (iRecv == SOCKET_ERROR))
		{
			iRecv = recvfrom(servSock, recvBuff, sizeof(recvBuff), 0, (SOCKADDR*)&clientName, &clen);
			if (iRecv > 0 && DebugLevel >= 1)
				PrintRecvInfo(clientName, &packet, ntohs(*(u_short*)recvBuff), Url, iRecv);
			stop = clock();
			duration = (double)(stop - start) / CLK_TCK;
			if (duration > 5)
			{
				printf("Long Time No Response From Server.\n");
				flag = 0;
				
				continue;
			}
		}

		if (flag == 1 && needAdd == 1) {
			DNS_Packet dns_packet;
			parseDNSPacket(&dns_packet, recvBuff);

			if (dns_packet.header->anCount > 0) {
				char* ip = (char*)malloc(sizeof(char) * 40);
				if (dns_packet.queries->qType == 1)
				{
					inet_ntop(AF_INET, dns_packet.answers->rData, ip, INET_ADDRSTRLEN);
				}
				else if (dns_packet.queries->qType == 28)
				{
					inet_ntop(AF_INET6, dns_packet.answers->rData, ip, INET6_ADDRSTRLEN);
				}
				else { ip[0] = '\0'; }
				cacheInfo ci = { 100,ip };
				cache.insert(make_pair(Url, ci));
				cout << ip << endl;

			}
		}

		//ID转换
		pID = (unsigned short*)malloc(sizeof(unsigned short*));
		memcpy(pID, recvBuff, sizeof(unsigned short)); //报文前两字节为ID
		int GetId = ntohs(*pID); //ntohs的功能：将网络字节序转换为主机字节序
		unsigned short oID = htons(id_trans_table[GetId].oid);
		memcpy(recvBuff, &oID, sizeof(unsigned short));
		id_trans_table[GetId].done = TRUE;

		//char* urlname;
		//memcpy(urlname, &(recvBuf[sizeof(DNSHDR)]), iRecv - 12);	//获取请求报文中的域名表示，要去掉DNS报文首部的12字节
		//char* NewIP;

		//打印 时间 newID 功能 域名 IP
		//PrintInfo(ntohs(NewID), getIP);

		//从ID转换表中获取发出DNS请求者的信息
		clientName = id_trans_table[GetId].client;

		//printf("We get a answer from SERVER, now we give it back to client.\n");

		//把recvbuf转发至请求者处
		iSend = sendto(localSock, recvBuff, iRecv, 0, (SOCKADDR*)&clientName, sizeof(clientName));
		if (iSend == SOCKET_ERROR)
		{
			//printf("sendto Failed: %s\n\n", strerror(WSAGetLastError()));
			isBusy[i] = false;
			return;
		}
		else if (iSend == 0)
		{
			isBusy[i] = false;
			return;
		}
		else if (iSend > 0 && DebugLevel > 0)
			PrintSendInfo(clientName, &packet, *pID, oID, getIP);
		free(pID); //释放动态分配的内存
	}

	//在域名解析表中找到
	else
	{
		//printf("We have find this url.\n");
		//获取请求报文的ID
		unsigned short nID = replace_id(ntohs(*pID), clientName, FALSE);

		//printf("We have get a new ID, now we will create an answer.\n");

		//打印 时间 newID 功能 域名 IP
		//if (DebugLevel >= 1)
			//PrintRecvInfo(clientName,packet,ntohs(pID),ntohl(NewID),Url);

		//构造响应报文头
		memcpy(sendBuf, recvBuff, iRecv); //拷贝请求报文
		unsigned short AFlag = htons(0x8180); //htons的功能：将主机字节序转换为网络字节序，即大端模式(big-endian) 0x8180为DNS响应报文的标志Flags字段
		memcpy(&sendBuf[2], &AFlag, sizeof(unsigned short)); //修改标志域,绕开ID的两字节

		//修改回答数域

		if (strcmp(getIP, "0.0.0.0") == 0)
			AFlag = htons(0x0000);	//屏蔽功能：回答数为0
		else
			AFlag = htons(0x0001);	//服务器功能：回答数为1
		memcpy(&sendBuf[6], &AFlag, sizeof(unsigned short)); //修改回答记录数，绕开ID两字节、Flags两字节、问题记录数两字节

		int curLen = 0; //不断更新的长度

		//构造DNS响应部分
		char answer[16];
		unsigned short Name = htons(0xc00c); //域名指针（偏移量）
		memcpy(answer, &Name, sizeof(unsigned short));
		curLen += sizeof(unsigned short);

		unsigned short TypeA = htons(0x0001); //类型
		memcpy(answer + curLen, &TypeA, sizeof(unsigned short));
		curLen += sizeof(unsigned short);

		unsigned short ClassA = htons(0x0001); //查询类
		memcpy(answer + curLen, &ClassA, sizeof(unsigned short));
		curLen += sizeof(unsigned short);

		//TTL四字节
		unsigned long timeLive = htonl(0x7b); //生存时间
		memcpy(answer + curLen, &timeLive, sizeof(unsigned long));
		curLen += sizeof(unsigned long);

		unsigned short RDLength = htons(0x0004); //资源数据长度
		memcpy(answer + curLen, &RDLength, sizeof(unsigned short));
		curLen += sizeof(unsigned short);

		unsigned long IP = (unsigned long)inet_addr(getIP); //inet_addr为IP地址转化函数
		memcpy(answer + curLen, &IP, sizeof(unsigned long));
		curLen += sizeof(unsigned long);
		curLen += iRecv;


		//请求报文和响应部分共同组成DNS响应报文存入sendbuf
		memcpy(sendBuf + iRecv, answer, curLen);


		iSend = sendto(localSock, sendBuf, curLen, 0, (SOCKADDR*)&clientName, sizeof(clientName));
		if (iSend > 0)
			PrintSendInfo(clientName, &packet, *pID, nID, getIP);


		free(pID); //释放动态分配的内存
		isBusy[i] = false;
		//printf("\nThis loop is over, thanks.\n\n");
	}
}
